# Two Factor Authentication (2FA)
### ‚è± 15 min build time 

## Why build two factor authentication?

Enterprises are increasingly challenged to keep sensitive information from falling into the wrong hands. This means that we can no longer trust old online authentication systems that rely solely on usernames and passwords, especially as security breaches grow in frequency, severity and sophistication.

With the [MessageBird Verify API](https://www.messagebird.com/en/verify), you can implement two factor authentication (2FA) solutions to provide an additional layer of account security by verifying the user's password with a second authentication token and in turn, secure customer data, block fraudulent accounts, and safeguard key transactions in a matter of minutes. The most common use case involves the application of one-time passwords (OTP) generated by hardware tokens or authenticator apps or directly sent to the user's mobile phone via SMS text messaging.

In this MessageBird Developer Guide, we'll introduce the [MessageBird Verify API](https://www.messagebird.com/en/verify) and show you how to build a runnable application in Go. The application is a prototype for a two-factor authentication system deployed by a fictious online banking application called *BirdBank*.

We will walk you through the following steps:

- Asking for the phone number
- Sending a verification code
- Verifying the code

You can follow along this tutorial to build the whole application from scratch or, if you want to see it in action right away, you can also [download, clone or fork the sample repository from GitHub](https://github.com/messagebirdguides/verify-guide-go).

## Getting started

We'll be building our single-page web application with:

* the latest version of [Go](https://golang.org), and
* the [MessageBird's REST API package for Go](https://github.com/messagebird/go-rest-api)

Before we get started, let's make sure you've downloaded the latest version of Go. If not, you can easily download it [here](https://golang.org) for free.

## Project Setup

First, let's create a folder for your application - you can call it whatever you like. Now, in this folder, let's create the 
following subfolders:

 - `views`
 - `views/layouts`

 We'll use the following packages from the Go standard library to build our routes and views:

- `net/http`: A HTTP package for building our routes and a simple http server.
- `html/template`: A HTML template library for building views.

### Dependencies

To keep things straightforward and get you up and running as fast as possible, we'll use only packages from the Go standard library and the MessageBird Client library.

#### Create your API Key üîë

To enable the MessageBird SDK, we need to provide an access key for the API. MessageBird provides keys in _live_ and _test_ modes. To get this application running, we will need to create and use a live API access key. Read more about the difference between test and live API keys [here] (https://support.messagebird.com/hc/en-us/articles/360000670709-What-is-the-difference-between-a-live-key-and-a-test-key-).

Let's create your live API access key. First, go to the [MessageBird Dashboard](https://dashboard.messagebird.com/en/user/index); if you have already created an API key it will be shown right there. If you do not see any key on the dashboard or if you're unsure whether this key is in _live_ mode, go to the _Developers_ section and open the [API access (REST) tab](https://dashboard.messagebird.com/en/developers/access). Here, you can create new API keys and manage your existing ones.

If you are having any issues creating your API key, please reach out to our Customer Support team at support@messagebird.com.

**Pro-tip:** To keep our demonstration code simple, we will be saving our API key in `main.go`. However, hardcoding your credentials in the code is a risky practice that should never be used in production applications. A better method, also recommended by the [Twelve-Factor App Definition](https://12factor.net/), is to use environment variables. You can use open source packages such as [GoDotEnv](https://github.com/joho/godotenv) to read your API key from a `.env` file into your Go application. Your `.env` file should be written as follows:

`````env
MESSAGEBIRD_API_KEY=YOUR-API-KEY
`````

To use [GoDotEnv](https://github.com/joho/godotenv) in your application, install it by running:

````bash
go get -u github.com/joho/godotenv
````

Then, import it in your application:

````go
import (
  // Other imported packages
  "os"

  "github.com/joho/godotenv"
)

func main(){
  // GoDotEnv loads any ".env" file located in the same directory as main.go
  err := godotenv.Load()
  if err != nil {
    log.Fatal("Error loading .env file")
  }

  // Store the value for the key "MESSAGEBIRD_API_KEY" in the loaded '.env' file.
  apikey := os.Getenv("MESSAGEBIRD_API_KEY")

  // The rest of your application ...
}
````

## Initialize the MessageBird Client

Let's now install the [MessageBird's REST API package for Go](https://github.com/messagebird/go-rest-api) by running:

````go
go get -u github.com/messagebird/go-rest-api
````

In your project folder which we created earlier, let's create a `main.go` file, and write the following code:

````go
package main

import (
  "github.com/messagebird/go-rest-api"
)

func main(){
  client := messagebird.New(<enter-your-apikey>)
}
````

### Routes

To make the structure of our web application clear, we'll first stub the routes that we need. We need three routes:

- Step 1: A route to ask for the user's phone number.
- Step 2: A route for the user to enter a verification code.
- Step 3: A route to show if the verification code is valid.

To write these routes, we need to modify `main.go` to look like the following:

````go
package main

import (
  "fmt"
  "net/http"

  "github.com/messagebird/go-rest-api"
)

func step1(w http.ResponseWriter, r *http.Request){
  // Do nothing
  fmt.Fprintln("This is step 1")
}

func step2(w http.ResponseWriter, r *http.Request){
  // Do nothing
  fmt.Fprintln("This is step 2")
}

func step3(w http.ResponseWriter, r *http.Request){
  // Do nothing
  fmt.Fprintln("This is step 3")
}

func main(){
  client := messagebird.New(<enter-your-apikey>)

  http.HandleFunc("/",step1)
  http.HandleFunc("/step2",step2)
  http.HandleFunc("/step3",step3)

  err := http.ListenAndServe(":8080",nil)
  if err != nil {
    panic(err)
  }
}
````

Here, we've defined a HTTP handler for each route, and assigned each handler to a corresponding URL path. At the bottom of our `main()` function, we start a HTTP server on port 8080.

**Pro-tip:** We use `http.ListenAndServe` to start our HTTP server here, but you may want to use `http.ListenAndServeTLS` to secure your application's communication over the web with TLS/SSL.

### Views

Now that we've got our routes set up, we can start writing templates to render for each route. We'll be defining four views:

 - `views/layouts/default`: The base HTML template we will use with all our views.
 - `views/step1`: View for step 1.
 - `views/step2`: View for step 2.
 - `views/step3`: View for step 3.

Let's create the following files in your project folder:

- `views/layouts/default.gohtml`
- `views/step1.gohtml`
- `views/step2.gohtml`
- `views/step3.gohtml`

The `.gohtml` files will contain our Go HTML template code for each of our views, and our "default" base template.

First, we'll write the base template. In `default.gohtml`, write the following code:

````html
{{ define "default" }}
<!DOCTYPE html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>MessageBird Verify Example</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="" type="text/css"/>
  </head>
  <body>
    <main class="">
    <h1>MessageBird Verify Example</h1>
    {{ template "yield" . }}
    </main>
  </body>
</html>
{{ end }}
````

Notice that in `default.gohtml`, we are calling `{{ template "yield" . }}`. This tells the Go templates package that the contents of any template named "yield" should be rendered in its place when the template is executed.

Next, modify the `import` call in `main.go` to add our HTML template package:

````go
import (
  "fmt"
  "net/http"
  "html/template"

  "github.com/messagebird/go-rest-api"
)
````

## Asking for the phone number

The first step in verifying a user's phone number is asking them to provide their phone number. So, in `step1.gohtml`, let's write the following code:

````html
{{ define "yield" }}
<p>Please enter your phone number (in international format, starting with +) to receive a verification code:</p>
<form method="post" action="/step2">
    <input type="tel" name="number" />
    <input type="submit" value="Send code" />
</form>
{{ end }}
````

Here in `step1.gohtml`, we see that our template is defined as "yield", allowing `default.gohtml` to render it when both templates are executed together by calling the `ExecuteTemplate()` method.

To get the view to render, open `main.go` and rewrite the `step1()` handler function:

````go
func step1(w http.ResponseWriter, r *http.Request) {
	t, err := template.ParseFiles("views/step1.gohtml","views/layouts/default.gohtml")
	if err != nil {
		log.Fatal(err)
	}
	err = t.ExecuteTemplate(w, "default", nil)
	if err != nil {
		log.Fatal(err)
  }
}
````

We tell the `step1()` handler to read both the "views/step1.gohtml" and "views/layouts/default.gohtml" template files. Then we call the `ExecuteTemplate` method, telling it render the "default" template.

## Writing a RenderDefaultTemplate() function

At this point, we know that the handlers for all three steps must:

- Parse the `default.gohtml` template file and one other template file.
- Execute the template.
- Handle errors from the `ParseFiles()` and `ExecuteTemplate()` methods.

We can write a `RenderDefaultTemplate()` helper function to make these calls, keeping our code DRY:

````go
func RenderDefaultTemplate(w http.ResponseWriter,thisView string){
  // Create an array of strings to contain our list of templates to render.
  renderthis := []string{thisView, "views/layouts/default.gohtml"}
	t, err := template.ParseFiles(renderthis...)
	if err != nil {
		log.Fatal(err)
	}
	err = t.ExecuteTemplate(w, "default", nil)
	if err != nil {
		log.Fatal(err)
	}
}
````

Then, we can go ahead and rewrite all our handlers in `main.go`:

````go
func step1(w http.ResponseWriter, r *http.Request){
  RenderDefaultTemplate(w,"views/step1.gohtml")
}

func step2(w http.ResponseWriter, r *http.Request){
  RenderDefaultTemplate(w,"views/step2.gohtml")
}

func step3(w http.ResponseWriter, r *http.Request){
  RenderDefaultTemplate(w,"views/step3.gohtml")
}
````


## Sending a verification code

Once we've collected the number, we can send a verification message to the user's mobile device. MessageBird's Verify API takes care of generating a random token, so you don't have to do this yourself. Codes are numeric and six digits by default. If you want to customize the length of the code or configure other options, you can refer to the [Verify API documentation](https://developers.messagebird.com/docs/verify#verify-request).

Next, we need a page with `step2()` for our user to enter their verification code.

In `step2.gohtml`, let's write the following code:

````html
{{ define "yield" }}
<p>We have sent you a verification code!</p>
<p>Please enter the code here:</p>
<form method="post" action="/step3">
    <input type="text" name="token" />
    <input type="submit" value="Check code" />
</form>
{{ end }}
````

Then, modify `step2()` in `main.go` to look like the following: 

````go
func step2(w http.ResponseWriter, r *http.Request) {
	var err error

	r.ParseForm()
	num := r.FormValue("number")
	clientVerify, err = client.NewVerify(num, nil)
	if err != nil {
		log.Println(err)
	}
	RenderDefaultTemplate(w, "views/step2.gohtml")
}
````

In the `step2()` handler, we're using the `ParseForm()` method to read data submitted through the form in `step1.gohtml`. We can access these values using the `FormValue(<key>)` method.

Here, we get the user's phone number using `FormValue("number")`, and pass it into `client.NewVerify()`, that sends this data to the MessageBird servers. The MessageBird servers then responds with `Verify` object that contains information we need for the verification process. Because we want to share the response received from the MessageBird server with the `step3` handler, we need to create two global variables in `main.go`. 

Just under our `import` statement in `main.go`, create the following variables:

````go
import (
  //...
)

var (
	// Stores the MessageBird Client object
  client       *messagebird.Client
  // Stores the Verify object received from the MessageBird servers
	clientVerify *messagebird.Verify
)

// The rest of the application...
````

Then, modify `step2()`:

````go
func step2(w http.ResponseWriter, r *http.Request) {
	var err error

	r.ParseForm()
	num := r.FormValue("number")
	clientVerify, err = client.NewVerify(num, nil)
	if err != nil {
		log.Println(err)
	}
	RenderDefaultTemplate(w, "views/step2.gohtml")
}
````

And, finally, modify `main()`:

````go
func main() {
  client = messagebird.New(<enter-your-apikey>)

  // The rest of your applicaiton...
}
````

## Verifying the code

If everything runs smoothly, the user will check their phone, enter their verification code and submit the form. We now need to send the verification token along with the ID received in the `clientVerify` object in `step2()`.

In `step3.gohtml`, let's write the following code:

````html
{{ define "yield" }}
    <h1>Done!</h1>
    <p>You have successfully verified your phone number.</p>
{{ end }}
````

Then, modify `step3()` in `main.go` to look like the following:

````go
func step3(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	token := r.FormValue("token")
	clientVerifyDone, err := client.VerifyToken(clientVerify.ID, token)
	if err != nil {
		log.Println(err)
	}
	// Execute template and pass verify.Status as a variable into the step3.gohtml template.
	RenderDefaultTemplate(w, "views/step3.gohtml")
}
````

In `step3()`, we parse the form data submitted in `step2` for the verification token, and send the token and the verification ID that we've stored in `clientVerify` to the MessageBird servers with `client.VerifyToken(clientVerify.ID, token)`.

## Displaying success state (optional)

When we submit the verification token, the MessageBird servers responds with another `Verify` object, which we store in `clientVerifyDone`. If the token is successfully verified, then the value of `clientVerifyDone.Status` would be "verified". We can use this to display a success state in `step3.gohtml`.

To do this, we have to alter our `RenderDefaultTemplate()` function to allow us to pass data into the `ExecuteTemplate()` method.

In `main.go`, modify `RenderDefaultTemplate()`:

````go
func RenderDefaultTemplate(w http.ResponseWriter, thisView string, data interface{}) {
  // ...
	err = t.ExecuteTemplate(w, "default", data)
	if err != nil {
		log.Fatal(err)
	}
}
````

Then, modify the `RenderDefaultTemplate()` calls in our handlers to look like the following:

````go
func step1(...){
  // ...
  RenderDefaultTemplate(w,"views/step1.gohtml",nil)
}
func step2(...){
  // ...
  RenderDefaultTemplate(w,"views/step1.gohtml",nil)
}
func step3(...){
  // ...
  RenderDefaultTemplate(w,"views/step3.gohtml",clientVerifyDone)
}
````

This allows the `step3.gohtml` template to access data we pass through our `RenderDefaultTemplate` function. We then need to do the following:

1. Write a struct that we will pass into the `RenderDefaultTemplate` function.
2. The struct should contain one attribute, "Success", that is set to either `true` or `false`.
3. If token verification is successful, "Success" should be set to `true`. Otherwise, it should be set to `false`.
4. Modify `step3.gohtml` to display a success state if token verification is successful.

Now, let's modify `step3()` in `main.go`:

````go
func step3(w http.ResponseWriter, r *http.Request) {
  // ...
  type successState struct {
    Success bool
  }
  var s successState

  if clientVerifyDone.Status == "verified" {
    s = successState{Success: true}
  } else {
    s = successState{Success: false}
  }
  
  RenderDefaultTemplate(w, "views/step3.gohtml", s)
}
````

Then, rewrite `step3.gohtml` such that it looks like this:

````html
{{ define "yield" }}
  {{ if .Success }}
    <h1>Done!</h1>
    <p>You have successfully verified your phone number.</p>
  {{ else }}
    <h1>Error</h1>
    <p>Something went wrong. Please try again</p>
  {{ end }}
{{ end }}
````

## Testing

You're done! To check if your application works, go to your project folder in your terminal and run:

````bash
go build main.go
./main
````

Then, point your browser to [http://localhost:8080/](http://localhost:8080/) and try to verify your own phone number.

## Nice work!

You now have a running integration of MessageBird's Verify API!

You can now leverage the flow, code snippets and UI examples from this tutorial to build your own two factor authentication system. Don't forget to download the code from the [MessageBird Developer Guides GitHub repository](https://github.com/messagebirdguides/verify-guide-go).

## Next steps

Want to build something similar but not quite sure how to get started? Please feel free to let us know at support@messagebird.com, we'd love to help!
